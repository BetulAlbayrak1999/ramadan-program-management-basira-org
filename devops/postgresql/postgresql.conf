# PostgreSQL Configuration optimized for high concurrency
# Server Specs: 12GB RAM, 6 CPU cores, 100GB SSD
# Optimized for: Web application with moderate to high concurrency

# ============================================
# CONNECTION SETTINGS
# ============================================
# Scale based on server capacity and expected load
# Consider using PgBouncer for connection pooling in production
max_connections = 300                   # Reduced from 1000 - use connection pooler for higher
superuser_reserved_connections = 3

# ============================================
# MEMORY SETTINGS (12GB RAM total)
# ============================================
# Allocate ~8GB to PostgreSQL, rest for OS and other services
shared_buffers = 3GB                    # 25% of RAM (3/12)
effective_cache_size = 9GB              # 75% of RAM (9/12) - OS + PG cache
work_mem = 4MB                          # Per-operation memory (4MB * 300 connections * 2 = 2.4GB max)
maintenance_work_mem = 512MB            # For VACUUM, CREATE INDEX, etc.
autovacuum_work_mem = 512MB             # Separate autovacuum memory

# ============================================
# PARALLELISM SETTINGS (6 CPU cores)
# ============================================
max_worker_processes = 6                # Match CPU core count
max_parallel_workers_per_gather = 3     # 50% of cores per query
max_parallel_workers = 6                # Total parallel workers across all queries
max_parallel_maintenance_workers = 3    # For CREATE INDEX, VACUUM

# ============================================
# CHECKPOINT CONFIGURATION
# ============================================
checkpoint_completion_target = 0.9      # Spread checkpoint I/O
wal_buffers = 16MB                      # Amount of WAL data buffered in memory
min_wal_size = 1GB                      # Minimum WAL file size
max_wal_size = 4GB                      # Maximum WAL file size
checkpoint_timeout = 15min              # Maximum time between checkpoints

# ============================================
# QUERY PLANNER (SSD Optimized)
# ============================================
random_page_cost = 1.1                  # Lower for SSD (default 4.0 for HDD)
effective_io_concurrency = 200          # SSD can handle many concurrent I/O
seq_page_cost = 1.0                     # Sequential scan cost
default_statistics_target = 100         # Statistics gathering detail

# ============================================
# WRITE AHEAD LOG (WAL)
# ============================================
wal_level = replica                     # Enable replication capability
wal_compression = on                    # Compress WAL data
wal_log_hints = on                      # Required for pg_rewind
archive_mode = off                      # Enable when setting up backup/replication

# ============================================
# LOGGING CONFIGURATION
# ============================================
logging_collector = on
log_destination = 'stderr'
log_directory = '/var/log/postgresql'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_truncate_on_rotation = on
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# What to log
log_checkpoints = on
log_connections = on
log_disconnections = on
log_duration = off
log_lock_waits = on                     # Log when queries wait for locks
log_statement = 'none'                  # none, ddl, mod, all
log_min_duration_statement = 1000       # Log queries slower than 1 second
log_timezone = 'UTC'

# ============================================
# REPLICATION (for future HA setup)
# ============================================
max_wal_senders = 5                     # Max replication connections
max_replication_slots = 5
wal_keep_size = 1GB                     # Retain WAL for replication

# ============================================
# CONNECTION & QUERY TIMEOUTS
# ============================================
idle_in_transaction_session_timeout = 60000  # 60 seconds - kills idle transactions
statement_timeout = 30000                     # 30 seconds - kills long-running queries
lock_timeout = 10000                          # 10 seconds - fails if lock not acquired

# ============================================
# AUTOVACUUM (Critical for OLTP workloads)
# ============================================
autovacuum = on
autovacuum_max_workers = 4              # Concurrent vacuum workers
autovacuum_naptime = 10s                # Check interval
autovacuum_vacuum_threshold = 50        # Min rows before vacuum
autovacuum_analyze_threshold = 50       # Min rows before analyze
autovacuum_vacuum_scale_factor = 0.1    # 10% of table size
autovacuum_analyze_scale_factor = 0.05  # 5% of table size
autovacuum_vacuum_cost_delay = 10ms     # Throttle autovacuum I/O
autovacuum_vacuum_cost_limit = 1000     # I/O budget per round

# ============================================
# LOCALE & FORMATTING
# ============================================
datestyle = 'iso, mdy'
timezone = 'UTC'
lc_messages = 'en_US.utf8'
lc_monetary = 'en_US.utf8'
lc_numeric = 'en_US.utf8'
lc_time = 'en_US.utf8'
default_text_search_config = 'pg_catalog.english'

# ============================================
# SECURITY
# ============================================
ssl = off                                # Enable with proper certificates in production
password_encryption = scram-sha-256     # Modern password hashing
shared_preload_libraries = 'pg_stat_statements'  # Performance monitoring

# ============================================
# PERFORMANCE MONITORING
# ============================================
track_activities = on
track_counts = on
track_io_timing = on                    # Measure I/O timing overhead
track_functions = all                   # Track function execution
pg_stat_statements.track = all          # Track all SQL statements
